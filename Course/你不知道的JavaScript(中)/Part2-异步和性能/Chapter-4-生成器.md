# 生成器

## 打破完整运行

ES6 中引入了一个新的函数类型，它并不符合这种运行到结束的特性。这类新的函数被称为生成器。
```
function* foo() { .. }
function *foo() { .. }
function*foo() { .. }
```
这几种形式在功能和语法上都是等同的，完全是一个风格偏好问题。  
我们可以这样运行前面的代码，使得 bar() 在 *foo() 内部的 yield 处执行呢？
```
var x = 1

function *foo() {
  x++
  yield // 暂停
  console.log("x": x)
}

function bar() {
  x++
}
// 构造一个迭代器 it 来控制这个生成器
var it = foo()

// 这里启动 foo()
it.next()
x // 2
bar()
x // 3
it.next() // x:3
```

(1) it = foo() 运算并没有执行生成器 *foo()，而只是构造了一个迭代器，这个迭代器会控制它的执行。  
(2)第一个 it.next() 启动了生成器 *foo()，并运行了 *foo() 第一行的 x++  
(3)*foo 在 yield 语句处暂停，在这一点上第一个 it.next() 调用结束。此时 *foo() 人在运行并且是活跃的，但处于暂停状态。

### 输入和输出
生成器函数是一个特殊的函数，但是他仍然是一个函数，这意味着它仍然有一些基本的特性没有改变。比如，它仍然可以接受参数，也能够返回值。

## 生成器产生值

### 产生者与迭代器


