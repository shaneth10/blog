# 第三章 Array 的变化侦测

Object 的侦测方式是通过 getter/setter 实现的，但类似 push 方法来改变数组，并不会触发 getter/setter 。

正因为我们可以通过 Array 原型上的方法来改变数组的内容，所以 Object 那种通过 getter/setter 的实现方式就行不通了。

## 如何追踪变化

我们可以用一个拦截器覆盖 Array.prototype。之后，每当使用 Array 原型上的方法操作数组时，其实执行的都是拦截器中提供的方法。然后再拦截器中使用原生 Array 的原型方法去操作数组。

## 拦截器

## 使用拦截器覆盖 Array 原型

## 将拦截器方法挂载到数组的属性上

## 如何收集依赖

## 依赖列表存在哪儿

## 收集依赖

## 在拦截器中获取 Observer 实例

## 向数组的依赖发送通知

## 侦测数组中元素的变化

## 侦测新增元素的变化

## 关于 Array 的问题

## 总结

Array 追踪变化的方式和 Object 不一样。因为它是通过方法来改变内容的，所以我们通过创建拦截器去覆盖数组原型的方式来追踪变化。

为了不污染全局 Array.prototype ，我们在 Observer 中只针对那些需要侦测变化的数组使用 _proto_ 来覆盖原型方法，但 _proto_ 在 ES6 之前并不是标准属性，不是所有浏览器都支持它。因此，针对不支持 _proto_ 属性的浏览器，我们直接循环拦截器，把拦截器中的方法直接设置到数组身上来拦截 Array.prototype 上的原生方法。

Array 收集依赖的方式和 Object 一样，都是在 getter 中收集。但是由于使用依赖的位置不同，数组要在拦截器中向依赖发消息，所以以来不能像 Object 那样保存在 defineReactive 中，而是把依赖保存在了 Observer 实例上。

在 Observer 中，我们对每个侦测了变化的数据都标上印记 _ob_ ，并把 this (Observer 实例) 保存在 _ob_ 上。这主要有两个作用，一方面是为了标记数据是否被侦测了变化（保证同一个数据只被侦测一次），另一方面可以很方便地通过数据取到 _ob_ ，从而拿到 Observer 实例上保存的依赖。当拦截到数组发生变化时，向依赖发送通知。

除了侦测数组自身的变化外，数组中元素发生的变化也要侦测。我们在 Observer 中判断如果当前被侦测的数据是数组，则调用 observeArray 方法将数组中的每一个元素都转换成响应式的并侦测变化。 

除了侦测已有数据外，当用户使用 push 等方法想数组中新增数据时，新增的数据也要进行变化侦测。我们使用当前操作数组的方法来进行判断，如果是 push、unshift 和 splice 方法，则从参数中将新增数据提取出来，然后使用 observeArray 对新增数据进行变化侦测。

由于在 ES6 之前，JavaScript 并没有提供元编码的能力，所以对于数组类型的数据，一些语法无法追踪到变化，只能拦截原型上的方法，而无法拦截数组特有的语法，例如使用 length 清空数组的操作就无法拦截。