# ES?现在与未来

## 1.1 版本
## 1.2 transpiling

# 语法

## 2.1 块作用域声明

JavaScript 中变量作用域的基本单元一直是 function。如果需要创建一个块作用域，最普遍的方法除了普通的函数声明之外，就是立即调用函数表达式。举例来说：
```
var a = 2;

(function IIFE() {
  var a = 3;
  console.log( a ) // 3
})()

console.log( a ) // 2
```
### 2.1.1 let 声明
但现在，我们可以创建绑定到任意块的声明，起被称为块作用域。  
在 let 声明/初始化之前访问 let 声明的变量会导致错误，而使用 var 的话这个顺序是无关紧要的：
```
{
  console.log(a) // undefined
  console.log(b) // ReferenceError

  var a
  let b
}
```

** let + for **
我建议使用 let 声明块的显示形式，唯一的例外是 let 出现在 for 循环头部的情况。原因可能有点微妙，但是我认为这是 ES6 的重要特性之一。for 循环头部的 let i 不只为 for 循环本身声明了一个 i，而是为循环的每一次迭代都重新声明了一个新的 i。这意味着 loop 迭代内部创建的闭包封闭的是每次迭代中的变量。

### 2.1.2 const 声明
还有一个块作用域声明形式需要了解：const，用于创建常量。这个变量的值在声明时设定之后就不允许改变。const 声明必须要有显示的初始化。如果需要一个值为 undefined 的常量，就要声明 ```const a = undefined```。   
常量不是对这个值本身的限制，而是对赋值的那个变量的限制。换句话说，这个值并没有因为 const 被锁定或者不可变，只是赋值本身不可变。如果这个值是复杂值，比如对象或者数组，其内容仍然是可以修改的。
```
{
  const a = [1,2,3]
  a.push(4)
  console.log(a)

  a = 42
}
```

### 2.1.3 块作用于函数
从 ES6 开始，块内声明的函数，其作用域在这个块内。   
```
{
  foo() // 可以这么做

  function foo() {
    // ..
  }
}

foo() // ReferenceError
```

## 2.2 spread/rest

ES6 引入了一个新的运算符 ...，通常称为 spread 或 rest 运算符，取决于它在哪/如何使用。
```
function foo(x, y, z) {
  console.log(x, y, z)
}

foo(...[1,2,3]) // 1 2 3
```
当...用在数组之前时，它会把这个变量“展开”伟哥哥独立的值。...为我们提供了可以替代 apply(...) 方法的一个简单的语法形式，在前 ES6 中我们常常这样写：
```
foo.apply(null, [1,2,3]) // 1 2 3
```
然而，...也可以在其他上下文中用来展开/扩展一个值，比如在另一个数组声明中：
```
var a = [2,3,4]
var b = [1,...a,5]
console.log(b) // [1,2,3,4,5]
```
在这种用法中，...基本上代替了concat(..)，这里的行为就像是[1].concat(a,[5])。...的另外一种常见用法基本上可以被看作凡响的行为；与把一个值展开不同，...把一系列值收藏到一起称为一个数组。
```
function foo(x, y, ...z) {
  console.log(x, y, z)
}

foo(1,2,3,4,5) // 1 2 [3,4,5]
```

## 2.3 默认参数值

我们可以讨论 ES6 新增的一个有用的语法来改进为缺失参数赋默认值的流程。
```
function foo(x = 11, y = 31) {
  console.log( x + y )
}

foo() // 42
foo(5, 6) // 11
foo(0, 42) // 42

foo(5) // 36
foo(5, undefined) // 36
foo(5, null) // 5 null被强制转换为0

foo(undefined, 6) // 17
foo(null, 6) // null被强制转换为0
```
**默认值表达式**   
函数默认值可以不只是像 31 这样的简单值；它们可以是任意合法表达式，甚至是函数调用。

## 2.4 解构

ES6 引入了一个新的语法特性，名为**解构**，把这个功能看作是一个**结构化赋值**方法，可能会容易理解一些。

### 2.4.1 对象属性赋值模式 
```
var X = 10, Y = 20;
var o = { a: X, b: Y };
console.log( o.a, o.b); // 10 20
```
在```{a: X, b: Y}```中，我们知道 a 是对象属性，而 X 是要赋给它的值。换句话说，这个语法模式是 target: source，因为它和赋值符 = 的模式一样都是 target = source，所以我们很直观地理解了这一点。   
但是，在使用对象结构赋值的时候——也就是说，把看起来像是对象字面值的语法{ .. }放在 = 运算符的左侧——反转了 target: source 模式。  
回忆一下：  
```
var { x: bam, y: baz, z: bap } = bar()
```
这里的语法模式是source: target。x 属性是源值，而 bam 是要赋值的目标变量。换句话说，对象字面值是 target <-- source，而对象结构赋值是 source --> target。

### 2.4.2 不只是声明
我们已经在 var 声明中应用了结构赋值，但是结构是一个通用的赋值操作，不只是声明。  
```
var a,b,c,x,y,z;

[a,b,c] = foo()
({x, y, z} = bar())
```
特别对于对象结构形式来说，如果省略了 var/let/const 声明符，就必须把整个赋值表达式用（）括起来。因为如果不这样做，语句左侧的{..}作为语句中的第一个元素就会被当作是一个快语句而不是一个对象。   
注意：除非需要把所有的赋值表达式都当作声明，否则不应该在赋值中混入声明。

### 2.4.3 重复赋值  
对象解构形式允许多次列出同一个源属性。举例来说：
```
var { a: X, a: Y } = { a: 1 }
X // 1
Y // 1
```
这也意味着可以解构子对象/数组属性，同时捕获子对象/类的值本身。  
记住：解构的目的不只是为了打字更少，而是为了可读性更强。   
**结构表达式**   
对象或者数组解构的赋值表达式的完成值是所有右侧/数组的值。  
```
var o = { a: 1, b: 2, c: 3 }, a, b, c, p
p = { a, b, c } = o
console.log( a, b, c ) // 1 2 3
p === o // true
```
p 赋值为对象 o 的引用，而不是 a、b 或者 c 的值之一，数组解构也是这样。通过持有对象/数组的值作为完成值，可以把解构赋值表达式组成链。

## 2.5 太多，太少，刚刚好

对于数组解构赋值和对象解构赋值来说，你不需要把存在的所有值都用来赋值。类似地，如果为比解构/分解出来的值更多的值赋值，那么就像期望的一样，多余的值会被赋值为 Undefined。  
```
var [,,c,d] = foo()
var {w, z} = bar()

console.log(c, z) // 3 6
console.log(d, w) // undefined undefined
```

### 2.5.1 默认值赋值
使用与前面默认函数参数值类似的 = 语法，解构的两种形式都可以提供一个用来赋值的默认值。

### 2.5.2 嵌套解构
如果解构的值中有嵌套的对象或者数组，也可以解构这些嵌套的值：
```
var a1 = [ 1, [2, 3, 4], 5 ]
var o1 = { x: { y: { z: 6} } }

var [ a, [b, c, d], e ] = a1
var { x: { y: { z: w } } } = o1

console.log( a, b, c, d, e ) // 1 2 3 4 5
console.log( w ) // 6
```
可以把嵌套解构当作一种展平对象名字空间的简单方法。
```
var App = {
  model: {
    User: function() { ... }
  }
}

var { model: { User } } = App
```

### 2.5.3 解构参数
这个技术已经接近于命名参数了，因为这里对象的属性映射到了同名的解构参数。这也意味着我们免费得到了可选参数功能；可以看到，省略”参数“x就像我们期望的那样工作。  
当然，前面介绍的包括嵌套解构、默认值等等都可用于参数解构。解构还可以和其他的 ES6 函数参数功能同时使用，比如默认参数值和 rest/gather 参数。  

**1.解构默认值+参数默认值**  