# ES?现在与未来

## 1.1 版本
## 1.2 transpiling

# 语法

## 2.1 块作用域声明

JavaScript 中变量作用域的基本单元一直是 function。如果需要创建一个块作用域，最普遍的方法除了普通的函数声明之外，就是立即调用函数表达式。举例来说：
```
var a = 2;

(function IIFE() {
  var a = 3;
  console.log( a ) // 3
})()

console.log( a ) // 2
```
### 2.1.1 let 声明
但现在，我们可以创建绑定到任意块的声明，起被称为块作用域。  
在 let 声明/初始化之前访问 let 声明的变量会导致错误，而使用 var 的话这个顺序是无关紧要的：
```
{
  console.log(a) // undefined
  console.log(b) // ReferenceError

  var a
  let b
}
```

** let + for **
我建议使用 let 声明块的显示形式，唯一的例外是 let 出现在 for 循环头部的情况。原因可能有点微妙，但是我认为这是 ES6 的重要特性之一。for 循环头部的 let i 不只为 for 循环本身声明了一个 i，而是为循环的每一次迭代都重新声明了一个新的 i。这意味着 loop 迭代内部创建的闭包封闭的是每次迭代中的变量。

### 2.1.2 const 声明
还有一个块作用域声明形式需要了解：const，用于创建常量。这个变量的值在声明时设定之后就不允许改变。const 声明必须要有显示的初始化。如果需要一个值为 undefined 的常量，就要声明 ```const a = undefined```。   
常量不是对这个值本身的限制，而是对赋值的那个变量的限制。换句话说，这个值并没有因为 const 被锁定或者不可变，只是赋值本身不可变。如果这个值是复杂值，比如对象或者数组，其内容仍然是可以修改的。
```
{
  const a = [1,2,3]
  a.push(4)
  console.log(a)

  a = 42
}
```

### 2.1.3 块作用于函数
从 ES6 开始，块内声明的函数，其作用域在这个块内。   
```
{
  foo() // 可以这么做

  function foo() {
    // ..
  }
}

foo() // ReferenceError
```

## 2.2 spread/rest

ES6 引入了一个新的运算符 ...，通常称为 spread 或 rest 运算符，取决于它在哪/如何使用。
```
function foo(x, y, z) {
  console.log(x, y, z)
}

foo(...[1,2,3]) // 1 2 3
```
当...用在数组之前时，它会把这个变量“展开”伟哥哥独立的值。...为我们提供了可以替代 apply(...) 方法的一个简单的语法形式，在前 ES6 中我们常常这样写：
```
foo.apply(null, [1,2,3]) // 1 2 3
```
然而，...也可以在其他上下文中用来展开/扩展一个值，比如在另一个数组声明中：
```
var a = [2,3,4]
var b = [1,...a,5]
console.log(b) // [1,2,3,4,5]
```
在这种用法中，...基本上代替了concat(..)，这里的行为就像是[1].concat(a,[5])。...的另外一种常见用法基本上可以被看作凡响的行为；与把一个值展开不同，...把一系列值收藏到一起称为一个数组。
```
function foo(x, y, ...z) {
  console.log(x, y, z)
}

foo(1,2,3,4,5) // 1 2 [3,4,5]
```

## 2.3 默认参数值

我们可以讨论 ES6 新增的一个有用的语法来改进为缺失参数赋默认值的流程。
```
function foo(x = 11, y = 31) {
  console.log( x + y )
}

foo() // 42
foo(5, 6) // 11
foo(0, 42) // 42

foo(5) // 36
foo(5, undefined) // 36
foo(5, null) // 5 null被强制转换为0

foo(undefined, 6) // 17
foo(null, 6) // null被强制转换为0
```
**默认值表达式**   
函数默认值可以不只是像 31 这样的简单值；它们可以是任意合法表达式，甚至是函数调用。

## 2.4 解构

ES6 引入了一个新的语法特性，名为**解构**，把这个功能看作是一个**结构化赋值**方法，可能会容易理解一些。

### 2.4.1 对象属性赋值模式 
```
var X = 10, Y = 20;
var o = { a: X, b: Y };
console.log( o.a, o.b); // 10 20
```
在```{a: X, b: Y}```中，我们知道 a 是对象属性，而 X 是要赋给它的值。换句话说，这个语法模式是 target: source，因为它和赋值符 = 的模式一样都是 target = source，所以我们很直观地理解了这一点。   
但是，在使用对象结构赋值的时候——也就是说，把看起来像是对象字面值的语法{ .. }放在 = 运算符的左侧——反转了 target: source 模式。  
回忆一下：  
```
var { x: bam, y: baz, z: bap } = bar()
```
这里的语法模式是source: target。x 属性是源值，而 bam 是要赋值的目标变量。换句话说，对象字面值是 target <-- source，而对象结构赋值是 source --> target。

### 2.4.2 不只是声明
我们已经在 var 声明中应用了结构赋值，但是结构是一个通用的赋值操作，不只是声明。  
```
var a,b,c,x,y,z;

[a,b,c] = foo()
({x, y, z} = bar())
```
特别对于对象结构形式来说，如果省略了 var/let/const 声明符，就必须把整个赋值表达式用（）括起来。因为如果不这样做，语句左侧的{..}作为语句中的第一个元素就会被当作是一个快语句而不是一个对象。   
注意：除非需要把所有的赋值表达式都当作声明，否则不应该在赋值中混入声明。

### 2.4.3 重复赋值