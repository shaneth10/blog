# ES?现在与未来

## 1.1 版本
## 1.2 transpiling

# 语法

## 2.1 块作用域声明

JavaScript 中变量作用域的基本单元一直是 function。如果需要创建一个块作用域，最普遍的方法除了普通的函数声明之外，就是立即调用函数表达式。举例来说：
```
var a = 2;

(function IIFE() {
  var a = 3;
  console.log( a ) // 3
})()

console.log( a ) // 2
```
### 2.1.1 let 声明
但现在，我们可以创建绑定到任意块的声明，起被称为块作用域。  
在 let 声明/初始化之前访问 let 声明的变量会导致错误，而使用 var 的话这个顺序是无关紧要的：
```
{
  console.log(a) // undefined
  console.log(b) // ReferenceError

  var a
  let b
}
```

** let + for **
我建议使用 let 声明块的显示形式，唯一的例外是 let 出现在 for 循环头部的情况。原因可能有点微妙，但是我认为这是 ES6 的重要特性之一。for 循环头部的 let i 不只为 for 循环本身声明了一个 i，而是为循环的每一次迭代都重新声明了一个新的 i。这意味着 loop 迭代内部创建的闭包封闭的是每次迭代中的变量。

### 2.1.2 const 声明
还有一个块作用域声明形式需要了解：const，用于创建常量。这个变量的值在声明时设定之后就不允许改变。const 声明必须要有显示的初始化。如果需要一个值为 undefined 的常量，就要声明 ```const a = undefined```。   
常量不是对这个值本身的限制，而是对赋值的那个变量的限制。换句话说，这个值并没有因为 const 被锁定或者不可变，只是赋值本身不可变。如果这个值是复杂值，比如对象或者数组，其内容仍然是可以修改的。
```
{
  const a = [1,2,3]
  a.push(4)
  console.log(a)

  a = 42
}
```

### 2.1.3 块作用于函数
从 ES6 开始，块内声明的函数，其作用域在这个块内。   
```
{
  foo() // 可以这么做

  function foo() {
    // ..
  }
}

foo() // ReferenceError
```

## 2.2 spread/rest

ES6 引入了一个新的运算符 ...，通常称为 spread 或 rest 运算符，取决于它在哪/如何使用。
```
function foo(x, y, z) {
  console.log(x, y, z)
}

foo(...[1,2,3]) // 1 2 3
```
当...用在数组之前时，它会把这个变量“展开”伟哥哥独立的值。...为我们提供了可以替代 apply(...) 方法的一个简单的语法形式，在前 ES6 中我们常常这样写：
```
foo.apply(null, [1,2,3]) // 1 2 3
```
然而，...也可以在其他上下文中用来展开/扩展一个值，比如在另一个数组声明中：
```
var a = [2,3,4]
var b = [1,...a,5]
console.log(b) // [1,2,3,4,5]
```
在这种用法中，...基本上代替了concat(..)，这里的行为就像是[1].concat(a,[5])。...的另外一种常见用法基本上可以被看作凡响的行为；与把一个值展开不同，...把一系列值收藏到一起称为一个数组。
```
function foo(x, y, ...z) {
  console.log(x, y, z)
}

foo(1,2,3,4,5) // 1 2 [3,4,5]
```

## 2.3 默认参数值