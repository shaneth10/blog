# 深入编程 

## 1.1 代码

程序常被称为**源码**或**代码**

## 1.2 表达式

语句由一个或多个表达式组成。一个表达式是对一个变量或值的引用，或者是一组值和变量与运算符的组合。一个独立的表达式也可以称为表达式语句。

## 1.3 实践

### 输出
### 输入
最常用的方法是：通过 HTML 页面向用户显示表单元素（如文本框）用于输入，然后通过 JavaScript 将这些值读取到程序变量中。  
还有一种更为简单的获取输入的方法，用于简单的学习和展示，这也是我们将会使用的方法，即 prompt(..) 函数：
```
age = prompt( "Please tell me your age:" );
console.log( age );
```

## 1.4 运算符

- 赋值 =
- 算术 + - * /
- 复合赋值 += -= *= /=
- 递增/递减 ++ -- 
- 对象属性访问 console.log()
- 相等 == === != !==
- 比较 < > <= >=
- 逻辑 && ||

## 1.5 值与类型

在编程术语中，对值的不同表示方法称为类型。JavaScript 为以下这些基本值提供了内置类型。  
- 数字 number
- 字符串 string
- 布尔值 boolean
直接包含在源码中的值被称为字面值。除了字符串/数字/布尔值类型，变成语言通常还会提供数组、对象、函数等。  

### 类型转换
显示的类型转换和隐式的类型转换

## 1.6 代码注释
## 1.7 变量

大多数的实用程序都需要跟踪值的变化，因为程序在执行任务时会对值进行各种操作，值会不断发生变化。   
在程序中实现这一点的最简单方法是将值赋给一个符号容器，这个符号容器称为变量。在某些编程语言中，你需要声明一个变量用于存放指定类型的值。通过避免不想要的值转换，人们认为这种静态类型（也称为类型强制）提高了程序的正确性。  
变量的主要用途就是管理程序状态，状态跟踪了值随着程序运行的变化。

## 1.8 块

我们常常需要将在代码中的一系列语句组合到一起，这些语句通常被称为块。在 JavaScript 中，使用一对大括号 { .. } 在一个或多个语句外来标识块。

## 1.9 条件判断

程序中有很多方法可以用于表示**条件判断**(也就是**决策**)。最常用的是 if 语句。

## 1.10 循环

 重复一系列动作，直到不满足某个条件，换句话说，重复只发生在满足条件的情况下，这就是程序循环的工作：循环有多种形式，但都满足基本的行为特征。循环包括测试条件以及一个块。循环块的每次执行被称为一个迭代。

 ## 1.11 函数

 程序总是需要将代码的任务分割成可复用的片段，而不是一直重复编码。实现这一点的方法就是定义一个**函数**

 ### 作用域
 在 JavaScript 中，每个函数都有自己的作用域。作用域基本上是比纳凉的一个集合以及如何通过名称访问这些变量的规则。只有函数内部的代码才能访问这个函数作用域中的变量。

 ## 1.12 总结

- 在值上执行动作需要**运算符**
- 执行各种类型的动作需要**值和类型**，比如，对数字进行数学运算，用字符串输出
- 在程序的执行过程中需要**变量**来保存数据（也就是**状态**）
- 需要 if 这样的条件判断来作出决策
- 需要循环来重复任务，直到不满足某个条件
- 需要**函数**将代码组织为逻辑上可复用的块

# 深入 JavaScript

## 2.1 值与类型

JavaScript 的值有类型，但变量无类型。以下是可用的内置类型：
- 字符串
- 数字
- 布尔值
- null 和 undefined
- 对象
- 符号（ES6）

JavaScript 提供了一个 typeof 的运算符，该运算符可以用来查看值的类型。typeof null 是一个有趣的示例，你期望它返回的会是“null”，但它返回的却是“object”。

### 2.1.1 对象
对象类型是指一个组合值，你可以为其设置属性，每个属性可以持有属于自己的任意类型的值。可以通过**点号**或者**中括号**来访问属性。   
**数组**和**函数**更应该被看作是对象类型的特殊子类型，而不是内置类型。

**1.数组**   
数组是一个持有（任意类型）值的对象，这些值不是通过命名属性/键值索引，而是通过数字索引位置。

**2.函数**   
函数也同样是对象的一个子类型，因为 typeof 返回 “function”，这意味着 function 是一个主类型，因此，function 可以拥有属性，但通常只在很少的情况下才会使用函数的对象属性。

### 2.1.2 内置类型方法
### 2.1.3 值的比较
JavaScript 程序中有两种主要的值比较：**相等**与**不等**。不管比较的类型是什么，任何比较的结果都是严格的布尔值（true 或者 false）。

**1.类型转换**  
JavaScript 中有两种类型转换：**显式的**类型转换与**隐式的**类型转换。显式的类型转换就是你可以在代码中看到的类型由一种转换到另一种，而隐式的类型转换多是某些其他运算可能存在的隐式副作用而引发的类型转换。

**2.真与假**
当非布尔型的值被强制转换为布尔型时，结果是 true 还是 false 呢？
假 的列表如下：
- ""（空字符串）
- 0、-0、NaN（无效数字）
- null、undefined
- false
任何不在 假 的列表中的值都是 真 值。

**3.相等**   
相等运算符有四种：==、===、!=、!==。== 和 === 的区别在于，== 检查值相等，而 === 检查值和类型相等。正确的说法是，== 检查的是允许类型转换情况下的值的相等性，而 === 检查不允许类型转换情况下的值的相等性。

- 如果要比较的两个值的任意一个（即一边）可能是 true 或者 false 值，那么要避免使用 ==，而使用 ===。  
- 如果要比较的两个值中的任意一个可能是特定值，那么避免使用 ==，而使用 ===。  
- 在所有其他情况下，使用 == 都是安全的。不仅仅只是安全而已，这在很多情况下也会简化代码，提高代码的可读性。

**4.不等关系**
```
var a = 42
var b = "foo"
a < b // false
a > b // false
a == b // false
```
比较中的值 b 都被类型转换为了”无效数字值“NaN，规范设定 NaN 既不大于也不小于任何其他值。== 比较的结果为假的原因则是，无论解释为 42 == NaN 还是 ”42“ == ”foo“ ,都会使得 a == b。

## 2.2 变量

如果使用关键字 var 声明一个变量，那么这个变量就属于当前的函数作用域，如果声明是发生在任何函数外的顶层声明，那么这个变量则属于全局作用域。

**1.提升**   
无论 var 出现在一个作用域中的哪个位置，这个声明都属于整个作用域，在其中到处都是可以访问的。   
这一行为被比喻地称为提升，在变量声明出现之前，依靠变量提升在其作用域使用这个变量并不常见。   

**2.嵌套作用域**  
声明后的变量在这个作用域内是随处可以访问的，包括所有低层/内层的作用域。

## 2.3 条件判断
```
if (a == 2) {
  // ...
} else if (a == 10) {
  // ...
}

switch (a) {
  case 2:
    // ...
    break;
  case 10:
    // ...
    break;
}
```

## 2.4 严格模式

ES5 为这个语言新增了”严格模式“，严格限制了某些行为的规则。一般来说，这些限制可以将代码保持在一个更安全、更适当的规范集合之内。另外，遵循严格模式也更容易让引擎优化你的代码，严格模式是代码的一次重大突破。

## 2.5 作为值的函数

不仅可以向函数传入值，函数本身也可以作为值赋给变量或者向其他函数传入，又或者从其他函数传出。
```
var foo = function() {
  // ..
}

var x = function bar() {
  // ..
}
```
第一个赋给变量 foo 的函数表达式被称为是匿名的。  
第二个函数表达式是已命名的，即使它的引用赋值给了变量 x。虽然匿名函数表达式的使用任然极为广泛，但通常更需要已命名函数表达式。

### 2.5.1 立即调用函数表达式
有一种方法可以执行函数表达式，这种方法通常被称为**立即调用函数表达式**
```
(function IIFE() {
  console.log("Hello!")
})()
// Hello
```
函数表达式外面的```(...)```就是 JavaScript 语法能够防止其成为普通函数声明的部分。表达式最后的（）实际上就表示立即执行前面给出的函数表达式。   
因为 IIFE 就是一个函数，而且函数会创建新的变量作用域，所以使用 IIFE 的这种风格也常用于声明不会影响 IIFE 外代码的变量，IIFE 也可以有返回值。

### 2.5.2 闭包
你可以将闭包看作”记忆“并在函数运行完毕后继续访问这个函数作用域（其变量）的一种方法。
```
function makeAdder(x) {
  // 参数x是一个内层变量

  // 内层函数add()使用x，所以它外围有一个”闭包“
  function add(y) {
    return y + x
  }

  return add
}
```
每次调用外层 makeAdder(..) 返回的、指向内层 add(..) 函数的引用能够记忆传入 makeAdder(..) 的 x 值。

**模块**  
在 JavaScript 中，闭包最常见的应用是模块模式。模块允许你定义外部不可见的私有实现细节（变量、函数），同时也可以提供允许从外部访问的公开 API。 
```
function User() {
  var username, password

  function doLogin(user, pw) {
    username = user
    password = pw
  }

  var publicAPI = {
    login: doLogin
  }

  return publicAPI
}

var fred = User()

fred.login('fred', '123456')
```

## 2.6 this标识符

虽然 this 一般与”面向对象的模式“相关，但 JavaScript 中的 this 则是另外一种机制。  
如果一个函数内部有一个 this 引用，那么这个 this 通常指向一个对象。this 并不指向这个函数本身，意识到这一点非常重要，因为这是最常见的误解。  
- 1.在非严格模式下，foo() 最后会将 this 设置为全局对象。在严格模式下，这是未定义的行为，在访问 bar 属性时会出错——因此”global“是为 this.bar 创建的值。
- 2.obj1.foo() 将 this 设置为对象 obj1。
- 3.foo.call(obj2) 将 this 设置为对象 obj2。
- 4.new foo() 将 this 设置为一个全新的空对象。

## 2.7 原型