# webpack 工作原理

了解 webpack 实现原理，掌握 webpack 基础的工作流程，在平时使用 webpack 遇见问题时，能够帮助我们洞察问题的根本所在，能够帮助我们理清解决问题的基本思路，同时也有助于我们更好地理解 loader 和 plugin 的使用和意义，在处理一些定制化的构建需求时更加得心应手。

抛开 webpack 复杂的 loader 和 plugin 机制，webpack 本质上就是一个 JS 模块 Bundler，用于将多个代码模块进行打包，所以我们先撇开 webpack 错综复杂的整体实现，来看一下一个相对简单的 JS 模块 Bunlder 的基础工作流程是怎么样的，在了解了 bundler 如何工作的基础上，再进一步去整理 webpack 整个流程，将 loader 和 plugin 的机制弄明白。

## 合并代码

笔者记得比较久远之前，在 js 的模块解决方案出来之前，一些前端类库为了拆分代码文件，会编写简单的合并代码文件的工具，有序得将多个代码文件合并到一起成为最终的 js 文件。举个例子：

```
// A.js
function A() {}

// B.js
function B() {}

// 结果
function A() {}
function B() {
  // 这里可以用 A 方法
}
```

这样的合并脚本很简单，读者们可以尝试用 Node 写一个。这样简单合并的方法有很明显的缺点，在代码库越来越大的时候会变得难以维护：

- 文件合并时的顺序很难确定
- 代码文件内变量和方法命名容易冲突

为了解决上述的问题，js 的模块解决方案就出来了，发展到今日，webpack 就是前端社区里最受欢迎的的 JS 模块 bundler。下边我们看下 webpack 是如何解决上述这两个问题的。

## 模块化

第一个问题，模块文件合并到一起时位置的顺序，简单理解也就是模块代码的执行顺序。CommonJS 规范和 ES Module 规范定义的就是在模块中声明依赖的方式，我们在模块中写下这样的代码：

```
// entry.js
import { bar } from './bar.js'; // 依赖 ./bar.js 模块

// bar.js
const foo = require('./foo.js'); // 依赖 ./foo.js 模块
```

便是在声明当前模块代码（即是入口的 entry.js）要执行时，需要依赖于「bar.js」模块的执行，而「bar.js」这个模块则依赖于「foo.js」。bundler 需要从这个入口代码（第一段）中解析出依赖 bar.js，然后再读取 bar.js 这个代码文件，解析出依赖 foo.js 代码文件，继续解析其依赖，递归下去，直至没有更多的依赖模块，最终形成一颗模块依赖树。

依赖解析和管理便是 webpack 这个 bundler 很重要的一个工作。如果 foo.js 文件没有依赖其他的模块的话，那么这个简单例子的依赖树也就相对简单：`entry.js -> bar.js -> foo.js`，当然，日常开发中遇见的一般都是相当复杂的代码模块依赖关系。

如果放到合并文件的处理上，上述的「foo.js」和「bar.js」模块的代码需要放到我们入口代码的前边。但是 webpack 不是简单地按照依赖的顺序合并，而是采取了一种更加巧妙的方式，顺带解决了前边提到的文件合并的第二个问题。