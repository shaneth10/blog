# 分离代码文件

我们之前介绍过如何使用 mini-css-extract-plugin 来将 CSS 代码单独拆分出来，而不是让它一起打包在 JS 代码中，这样做的好处有两个：

- 假如 JS 代码很多，拆分出来的 CSS 代码可以更快加载，一些 UI，例如 loading 等，可以更快地展示给到用户
- 有多个页面时，可以更好地利用拆分出来的 CSS 代码缓存来提高应用加载速度

因此当我们考虑更好地利用缓存来加速静态资源访问时，会尝试把一些公共资源单独分离开来，利用缓存加速，以避免重复的加载。除了公共的 CSS 文件或者图片资源等，当我们的 JS 代码文件过大的时候，也可以用代码文件拆分的办法来进行优化。

## 分离公共部分

我们来看下如何使用 webpack 来拆分公共的 JS 代码，一个最简单的例子：

```
module.exports = {
  // ... webpack 配置

  optimization: {
    splitChunks: {
      chunks: "all", // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件
      name: 'common', // 给分离出来的 chunk 起个名字
    },
  },
}
```

我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 commons.bundle.js 需要在入口代码之前。下面是个简单的例子：

```
<script src="commons.bundle.js" charset="utf-8"></script>
<script src="index.bundle.js" charset="utf-8"></script>
```

如果你使用了 html-webpack-plugin，那么对应需要的 JS 文件都会在 HTML 文件中正确引用，不用担心。如果你会根据页面区分不同的 JS 入口的话，那么在使用 html-webpack-plugin 时需要指定对应的 chunk：

```
module.exports = {
  // ...
  plugins: [
    new HtmlWebpackPlugin({
      filename: 'page.html',
      chunks: ['common', 'page'], // 这里要包括 common 部分和页面业务部分
    }),
  ]
}
```

如果没有使用 html-webpack-plugin 的话，那么你需要从 `stats` 的 `entrypoints` 属性来获取入口应该引用哪些 JS 文件，可以参考 Node API 了解如何从 `stats` 中获取信息，或者开发一个 plugin 来处理正确引用 JS 文件这个问题。后边的章节会介绍如何开发 webpack plugin，plugin 提供的 API 也可以正确获取到 `stats` 中的数据。

## splitChunks 配置项

`optimization.splitChunks` 中有很多个配置项，我们先逐一了解它们的作用：

chunks 表示从哪些模块中抽取代码，可以设置 `all/async/initial` 三个值其中一个，分别表示 `所有模块/异步加载的模块/同步加载的模块`，或者也可以设置一个 function，用于过滤掉不需要抽取代码的模块，例如：

```
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks (chunk) {
        // 排除 `my-excluded-chunk`
        return chunk.name !== 'my-excluded-chunk';
      }
    }
  }
};
```

function 的方式一般很少用到，后边我们会提到具体原因。

`minSize` 表示生成的公共代码文件最小的体积，而 maxSize 则是告诉 webpack 尽可能把大于这个设置值的代码量拆分成更小的文件来生成，默认为 0，即不限制。

`minChunks` 表示一个模块被多少个模块共享引用时要被抽离出来，默认为 1，如果设置为 2，即表示起码有两个模块引用了一个模块，这个被引用的模块才会被抽离出来。

`name` 是抽离出来的文件名称，默认为 true，即自动生成。

`automaticNameDelimiter` 抽取模块后生成的文件由多个模块的名称组成，这个选项用于配置多个名称组合时使用的连接符，默认是 `~`。

`cacheGroups` 是最关键的配置，表示抽离公共部分的配置，一个 key-value 的配置对应一个生成的代码文件，通常我们都会在这里下功夫，先看下简单的例子：

```
module.exports = {
  // ...
  optimization: {
    splitChunks: {
      cacheGroups: {
        defaultVendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        }
      },
    }
  }
}
```

上述的例子会抽离两个代码文件出来：`defaultVendors` 和 `default`，这两个的配置会继承 splitChunks 上的所有配置项，并且多了三个配置项：

- test 类似 loader 中的 test，用于匹配要抽离的代码模块。
- priority 权重配置，如果一个模块满足多个 cacheGroup 的匹配条件，那么就由权重来确定抽离到哪个 cacheGroup。
- reuseExistingChunk 设置为 true 表示如果一个模块已经被抽离出去了，那么则复用它，不会重新生成。

下边我们来看下如何使用这些配置来抽离项目中使用的第三方模块。



